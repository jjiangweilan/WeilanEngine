#version 460

#if CONFIG
name : IrradianceMapGeneration
debug : true
#endif

#if COMP


layout(push_constant) uniform Params
{
    vec4 texelSize;
};
layout(set = 0, binding = 0) uniform sampler2D _Src;
layout(set = 0, binding = 1, rgba32f) writeonly uniform imageCube _Dst;

layout(local_size_x = 8, local_size_y = 8) in;

vec3 GetDirFromCubeUV(vec2 uv, int faceIndex) {
    uv = 2.0 * uv - 1.0; // Normalize UV to range [-1, 1]

    if (faceIndex == 0) return vec3(1.0, -uv.y, -uv.x); // +X
    if (faceIndex == 1) return vec3(-1.0, -uv.y, uv.x); // -X
    if (faceIndex == 2) return vec3(uv.x, 1.0, uv.y); // +Y
    if (faceIndex == 3) return vec3(uv.x, -1.0, -uv.y); // -Y
    if (faceIndex == 4) return vec3(uv.x, -uv.y, 1.0); // +Z
    if (faceIndex == 5) return vec3(-uv.x, -uv.y, -1.0); // -Z

    return vec3(0.0);
}

#define PI2 6.28318530718
#define PI 3.14159265359
void main()
{
    if (gl_GlobalInvocationID.x >= texelSize.z || gl_GlobalInvocationID.y >= texelSize.w)
    {
        return;
    }
    vec2 uv = (gl_GlobalInvocationID.xy + vec2(0.5)) * texelSize.xy;
    vec3 normal = normalize(GetDirFromCubeUV(uv, int(gl_WorkGroupID.z)));

    vec3 tangent = normalize(normal != vec3(0.0f, 1.0f, 0.0f) ? cross(vec3(0.0f, 1.0f, 0.0), normal) : cross(vec3(0.0f, 0.0f, 1.0f), normal));
    vec3 binormal = cross(tangent, normal);

    float phiSampleDelta = 1.0f / 256.0f;
    float thetaSampleDelta = 1.0f / 128.0f;
    vec3 radiance = vec3(0);
    uint numSamples = 0;
    for (float p = 0.0; p < 1.0f; p += phiSampleDelta) {
        for (float t = 0.0; t < 1.0f; t += thetaSampleDelta) {
            float phi = p * 2.0f * PI;
            float theta = t * 0.5 * PI;

            vec3 tangentSample = normalize(vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)));
            vec3 sampleVec = tangentSample.x * tangent + tangentSample.y * binormal + tangentSample.z * normal;
            sampleVec = normalize(sampleVec);

            // equirectangular conversion
            float samplePhi = atan(sampleVec.z, sampleVec.x) + PI;
            float sampleTheta = acos(sampleVec.y);
            vec2 srcUV = vec2(samplePhi / PI2, sampleTheta / PI);

            // prevent crazy high value in hdr file
            vec3 val = min(textureLod(_Src, srcUV, 0.0).xyz, vec3(20)) * cos(theta) * sin(theta);
            radiance += val;
            numSamples++;
        }
    }

    imageStore(_Dst, ivec3(gl_GlobalInvocationID.xy, gl_WorkGroupID.z), vec4(PI * radiance / float(numSamples), 1.0f));
}
#endif
