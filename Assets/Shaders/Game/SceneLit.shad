ShaderPass GBuffer
{
// Reference: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
#version 460
#include "Common/Common.glsl"
#include "Common/DeferredShading.glsl"

#if CONFIG
name: Game/SceneLit
features:
    - [_, _AlphaTest]
    - [_, _BaseColorMap]
    - [_, _NormalMap]
    - [_, _EmissiveMap]
    - [_, _MetallicRoughnessMap]
    - [_, _Vertex_Normal]
    - [_, _Vertex_Tangent]
    - [_, _Vertex_UV0]
#endif

#if VERT
layout(location = 0) in vec3 i_Position;
layout(location = 1) in vec3 i_Normal;
#ifdef _Vertex_Tangent
layout(location = 2) in vec4 i_Tangent;
#endif
#ifdef _Vertex_UV0
layout(location = 3) in vec2 i_UV;
#endif

layout(location = 0) out vec3 o_PositionWS;
layout(location = 1) out vec3 o_NormalWS;
layout(location = 2) out vec3 o_TangentWS;
layout(location = 3) out vec3 o_BitangentWS;
layout(location = 4) out vec2 o_UV;

vec4 GetVertexTangent()
{
#ifdef _Vertex_Tangent
    return i_Tangent;
#else
    return vec4(1,0,0,0);
#endif
}

vec2 GetVertexUV0()
{
#ifdef _Vertex_UV0
    return i_UV;
#else
    return vec2(0);
#endif
}

void main()
{
    o_PositionWS = vec3(pconst.model * vec4(i_Position, 1));
    o_NormalWS = (inverse(transpose(pconst.model)) * vec4(i_Normal, 1)).xyz;
    vec4 tangent = GetVertexTangent();
    o_TangentWS = (inverse(transpose(pconst.model)) * vec4(tangent.xyz, 1)).xyz;
    o_BitangentWS = tangent.w * cross(o_NormalWS, o_TangentWS);
    o_UV = GetVertexUV0();

    gl_Position = scene.viewProjection * vec4(o_PositionWS, 1);
}
#endif

#if FRAG
layout(location = 0) in vec3 i_PositionWS;
layout(location = 1) in vec3 i_NormalWS;
layout(location = 2) in vec3 i_TangentWS; // maybe look at MikkTSpace
layout(location = 3) in vec3 i_BitangentWS;
layout(location = 4) in vec2 i_UV;

layout(location = 0) out vec4 o_Lighting;
layout(location = 1) out vec4 o_Albedo;
layout(location = 2) out vec4 o_Normal;
layout(location = 3) out vec4 o_Property;

#define BaseColorTex baseColorTex_sampler_linear
#define NormalMap normalMap_sampler_linear
#define EmissiveMap emissiveMap_sampler_linear
#define MetallicRoughnessMap metallicRoughnessMap_sampler_linear

layout(set = SET_MATERIAL, binding = 0) uniform PBR
{
    vec4 baseColorFactor;
    vec4 emissive;
    float roughness;
    float metallic;
    float alphaCutoff;
} matParams;

layout(set = SET_MATERIAL, binding = 1) uniform sampler2D BaseColorTex;
layout(set = SET_MATERIAL, binding = 2) uniform sampler2D NormalMap;
layout(set = SET_MATERIAL, binding = 3) uniform sampler2D MetallicRoughnessMap;
layout(set = SET_MATERIAL, binding = 4) uniform sampler2D EmissiveMap;
#define Roughness matParams.roughness
#define Metallic matParams.metallic
#define NearZero 0.000001

void main()
{
#ifdef _BaseColorMap
    vec4 baseColor = texture(BaseColorTex, i_UV) * matParams.baseColorFactor;
#else
    vec4 baseColor = matParams.baseColorFactor;
#endif

#ifdef _AlphaTest
    if (baseColor.a < matParams.alphaCutoff)
        discard;
#endif

#ifdef _MetallicRoughnessMap
    vec2 metallicRoughness = vec2(Roughness, Metallic) * texture(MetallicRoughnessMap, i_UV).gb;
    float metallic = metallicRoughness.y;
    float roughness = max(metallicRoughness.x, 0.01);
#else
    float metallic = Metallic;
    float roughness = Roughness;
#endif

#ifdef _NormalMap
    vec3 normal = texture(NormalMap, i_UV).xyz * 2 - 1;
#else
    vec3 normal = vec3(0,0,1);
#endif
    mat3 TBN = mat3(normalize(i_TangentWS), normalize(i_BitangentWS), normalize(i_NormalWS));
    vec3 n = EncodeGBufferNormal(normalize(TBN * normal));

#ifdef _EmissiveMap
    vec4 emission = texture(EmissiveMap, i_UV);
#else
    vec4 emission = vec4(0);
#endif

    o_Lighting = vec4(emission.xyz * matParams.emissive.xyz, 1.0f);
    o_Albedo = baseColor;
    o_Normal = vec4(n, 0);
    o_Property = vec4(metallic, roughness, 1, 0);
}
#endif
}

ShaderPass LightFieldProbeBake
{
#version 460

#if CONFIG
name: Game/SceneLit/LightFieldProbeBake
#endif

#if VERT

// input
layout(location = 0) in vec3 i_Position;
layout(location = 1) in vec3 i_Normal;
layout(location = 2) in vec4 i_Tangent;
layout(location = 3) in vec2 i_UV;
layout(push_constant) uniform Transform
{
    mat4 model;
} pconst;

// output
layout(location = 0) out vec3 o_PositionWS;
layout(location = 1) out vec3 o_NormalWS;
layout(location = 2) out vec3 o_TangentWS;
layout(location = 3) out vec3 o_BitangentWS;

layout(set = 1, binding = 0) uniform LFP
{
    mat4 viewProjection;
} lfp;

void main()
{
    o_PositionWS = vec3(pconst.model * vec4(i_Position, 1));
    o_NormalWS = (inverse(transpose(pconst.model)) * vec4(i_Normal, 1)).xyz;
    o_TangentWS = (inverse(transpose(pconst.model)) * vec4(i_Tangent.xyz, 1)).xyz;
    o_BitangentWS = i_Tangent.w * cross(o_NormalWS, o_TangentWS);

    gl_Position = lfp.viewProjection * vec4(o_PositionWS, 1);
}
#endif

#if FRAG
#include "Common/DeferredShading.glsl"
layout(location = 0) in vec3 i_PositionWS;
layout(location = 1) in vec3 i_NormalWS;
layout(location = 2) in vec3 i_TangentWS;
layout(location = 3) in vec3 i_BitangentWS;

layout(location = 0) out vec4 o_Albedo;
layout(location = 1) out vec4 o_Normal;

layout(set = 2, binding = 0) uniform PBR
{
    vec4 baseColorFactor;
    vec4 emissive;
    float roughness;
    float metallic;
    float alphaCutoff;
} matParams;
layout(set = 2, binding = 1) uniform sampler2D BaseColorTex;
layout(set = 2, binding = 2) uniform sampler2D NormalMap;

#define Roughness matParams.roughness
#define NearZero 0.000001

void main()
{
#ifdef _BaseColorMap
    vec4 baseColor = texture(BaseColorTex, i_UV) * matParams.baseColorFactor;
#else
    vec4 baseColor = matParams.baseColorFactor;
#endif

#ifdef _AlphaTest
    if (baseColor.a < matParams.alphaCutoff)
        discard;
#endif

#ifdef _NormalMap
    vec3 normal = texture(NormalMap, i_UV).xyz * 2 - 1;
#else
    vec3 normal = vec3(0,0,1);
#endif
    mat3 TBN = mat3(normalize(i_TangentWS), normalize(i_BitangentWS), normalize(i_NormalWS));
    vec3 n = EncodeGBufferNormal(normalize(TBN * normal));

    o_Albedo = baseColor;
    o_Normal = vec4(n, 0);
}
#endif
}
