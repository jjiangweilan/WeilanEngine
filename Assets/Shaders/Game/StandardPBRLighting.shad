// Reference: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
#version 460
#define G_PCF
#extension GL_KHR_shader_subgroup_arithmetic : enable
#include "Common/Common.glsl"
#include "Common/DeferredShading.glsl"

#if CONFIG
name: Game / StandardPBRLighting
features:
    - [ _, _AlphaTest ]
debug: true
#endif

#define LOC_ShadowMapCS 5

#if VERT
layout(location = 0) out vec2 o_uv;

void main()
{
    vec4 c_Positions[6] =
        {
        { -1, 1, 0.5, 1 },
        { -1, -1, 0.5, 1 },
        { 1, 1, 0.5, 1 },

        { -1, -1, 0.5, 1 },
        { 1, -1, 0.5, 1 },
        { 1, 1, 0.5, 1 }
        };

    gl_Position = c_Positions[gl_VertexIndex];
    o_uv = gl_Position.xy * 0.5f + 0.5f;
}
#endif

#if FRAG
layout(location = 0) in vec2 i_UV;
layout(set = 0, binding = 6) uniform sampler2D albedoTex;
layout(set = 0, binding = 7) uniform sampler2D normalTex;
layout(set = 0, binding = 8) uniform sampler2D maskTex;
layout(set = 0, binding = 9) uniform sampler2D depthTex_point;
#define depthTex depthTex_point
layout(set = 0, binding = 10) uniform sampler2D aoMap;
layout(set = 0, binding = 11) uniform TileComputeParams
{
    vec4 tileSize;
    float bucketCount;
};
layout(std430, set = 0, binding = 12) readonly buffer Tiles
{
    uint buckets[];
};

layout(set = 1) uniform ShadingProperties
{
    float shadowConstantBias;
    float shadowNormalBias;
} prop;

layout(location = 0) out vec4 o_Color;

#define NearZero 0.000001

float pow2(float x)
{
    return x * x;
}

const vec2 invAtan = vec2(0.1591, 0.3183);
vec2 SphericalToUV(vec3 v)
{
    // -asin because we have top-left uv origin
    vec2 uv = vec2(atan(v.z, v.x), -asin(v.y));

    // convert to [0,1]
    uv *= invAtan;
    uv += 0.5;
    return uv;
}

float Fresnel(float metallic, float dotVH)
{
    return metallic + (1 - metallic) * pow(2, (-5.55472 * dotVH - 6.98316) * dotVH);
}

float SpecularBRDF(vec3 l, vec3 v, vec3 n, float metallic, float roughness)
{
    vec3 h = normalize(l + v);
    float dotNH = max(dot(n, h), NearZero);
    float dotNV = max(dot(n, v), NearZero);
    float dotNL = max(dot(n, l), NearZero);
    float dotVH = max(dot(v, h), NearZero);
    float r2 = roughness * roughness;

    float D = r2 / (M_PI * pow2(pow2(dotNH) * (r2 - 1) + 1));

    // geometry
    float k = pow2(roughness + 1) / 8;
    float Gv = dotNV / (dotNV * (1 - k) + k);
    float Gl = dotNL / (dotNL * (1 - k) + k);
    float G = Gv * Gl;

    // fresnel
    float F = Fresnel(metallic, dotVH);

    float brdf = (G * F * D) / (4 * dotNL * dotNV);
    return brdf;
}

// http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation
float PointLightAttenuation(float distance, float t1, float t2)
{
    float s = distance / t2;
    if (s < 1)
    {
        s *= s;
        float n0 = (1 - s);
        return n0 * n0 / (1 + t1 * s);
    }
    else
        return 0;
}

#define OCCLUDER_SEARCH_ITS 100
vec3 ParallaxShadowReprojection(vec3 P1, vec3 L1, vec3 L0)
{ 
    float k = 1.0 + length(L1 - L0); 
    vec3 D = k * L1 - L0; 
 
    vec3 S = P1; 
    vec3 dS = D * 0.25; 
    float sum = 0, cnt = 0; 
    for (int i = 0; i < 8; ++i) 
    { 
        vec4 Sp = scene.worldToShadow * vec4(S, 1);
        Sp = Sp / Sp.w;
        vec2 shadowUV = Sp.xy * 0.5 + 0.5;
        float occDepth = textureLod(sampler2D(shadowMap, s_point_clamp), shadowUV, 0).r; 
        if (occDepth < Sp.z) 
        { 
            sum += (Sp.z - occDepth) * 1000.0f;  // shadow map is a depth texture from 0 to 1, we scale it with length of near and far plane
            cnt += 1; 
        } 
        S += dS; 
    } 
 
    float d0 = cnt > 0 ? sum * (1 / cnt) : 0; 
    vec3 P0 = P1 + d0 * D; 

    return P0;
} 

void main()
{
    vec3 n = DecodeGBufferNormal(texture(normalTex, i_UV).xyz);
    vec4 mask = texture(maskTex, i_UV);
    float metallic = mask.x;
    float roughness = mask.y;
    float ao = texture(aoMap, i_UV).x;
    vec3 baseColor = texture(albedoTex, i_UV).xyz;
    float depth = texture(depthTex, i_UV).x;
    vec4 positionWS = scene.invNDCToWorld * vec4(i_UV * 2 - 1, depth, 1.0);
    positionWS /= positionWS.w;
    vec3 v = normalize(scene.viewPos.xyz - positionWS.xyz);

    vec3 color = vec3(0, 0, 0);
    for (int i = 0; i < scene.lightCount.x; ++i)
    {
        vec4 lightPos = scene.lights[i].position;
        vec3 l = lightPos.a == 0 ? lightPos.xyz : normalize(lightPos.xyz - positionWS.xyz);

        float dotNL = max(dot(n, l), NearZero);
        float brdf = SpecularBRDF(l, v, n, metallic, roughness);

        vec3 light = dotNL * scene.lights[i].intensity * scene.lights[i].lightColor.xyz;
        float attenuation = lightPos.a == 0 ? 1 : PointLightAttenuation(distance(lightPos.xyz, positionWS.xyz), scene.lights[i].pointLightTerm1, scene.lights[i].pointLightTerm2);

        vec3 lighting = light * (ao * baseColor / M_PI + brdf) * attenuation; // this looks wrong for metal, metal shouldn't diffuse too much
        // possible solution https://bruop.github.io/ibl/
        // const float DIELECTRIC_SPECULAR = 0.04;
        // diffuseColor = albedo.rgb * (1 - DIELECTRIC_SPECULAR) * (1.0 - metalness)

        // shadow mask
        float shadowAttenuation = 1.0;
        if (lightPos.a == 0)
        {
            const float shadowBias = prop.shadowConstantBias;
            const float shadowNormalBias = prop.shadowNormalBias;

            vec3 shadowWorldPos = positionWS.xyz;
            if (scene.cachedMainLightDirection.a == 1.0f)
            {
                shadowWorldPos = ParallaxShadowReprojection(positionWS.xyz, l, scene.cachedMainLightDirection.xyz);
            }

            vec4 shadowCS = scene.worldToShadow * vec4(shadowWorldPos.xyz + shadowNormalBias * n, 1.0);
            shadowCS = shadowCS / shadowCS.w;
            vec2 shadowUV = shadowCS.xy * 0.5 + 0.5;
            float objShadowDepth = shadowCS.z - shadowBias;
            if (shadowUV.x < 1 && shadowUV.y < 1 && shadowUV.x > 0 && shadowUV.y > 0)
            {
                shadowAttenuation = PcfShadow(shadowUV, objShadowDepth);
            }
        }
        color += lighting * shadowAttenuation;
    }

    // diffuse cube light
    vec3 diffuseCubeColor = texture(diffuseCube, n).xyz;
    vec3 ambient = ao * baseColor * diffuseCubeColor / M_PI * (scene.lightCount.x > 0 ? scene.lights[0].ambientScale : 1);

    // vec3 emissive = texture(emissiveMap_sampler_linear, i_UV).xyz;

    o_Color = vec4(color + ambient, 1);
    // uvec2 viewCoord = uvec2(gl_FragCoord.x, scene.screenSize.y - gl_FragCoord.y);
    // uvec2 tileIndex2D = uvec2(viewCoord / 16);
    // uint tileIndex = uint(tileIndex2D.x + tileIndex2D.y * tileSize.z);
    // bool hasLight = false;
    // for (uint i = 0; i < 4; ++i)
    // {
    //     hasLight = hasLight || (buckets[uint(tileIndex * 4 + i)] != 0);
    // }
    // if (hasLight)
    //     o_Color += vec4(0.31, 0, 0, 1);
}
#endif
