// Reference: https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
// https://google.github.io/filament/Filament.html
#version 460
#define G_PCF
#extension GL_KHR_shader_subgroup_arithmetic : enable
#include "Common/Common.glsl"
#include "Common/DeferredShading.glsl"

#if CONFIG
name: Game / StandardPBRLighting
features:
    - [ _, _AlphaTest ]
debug: true
#endif

#define LOC_ShadowMapCS 5

#if VERT
layout(location = 0) out vec2 o_uv;

void main()
{
    vec4 c_Positions[6] =
        {
        { 1, 1, 0, 1 },
        { -1, -1, 0, 1 },
        { -1, 1, 0, 1 },

        { 1, -1, 0, 1 },
        { -1, -1, 0, 1 },
        { 1, 1, 0, 1 }
        };

    gl_Position = c_Positions[gl_VertexIndex];
    o_uv = gl_Position.xy * 0.5f + 0.5f;
}
#endif

#if FRAG
layout(location = 0) in vec2 i_UV;
layout(set = 0, binding = 6) uniform sampler2D albedoTex;
layout(set = 0, binding = 7) uniform sampler2D normalTex;
layout(set = 0, binding = 8) uniform sampler2D maskTex;
layout(set = 0, binding = 9) uniform sampler2D depthTex_point;
#define depthTex depthTex_point
layout(set = 0, binding = 10) uniform sampler2D aoMap;
layout(set = 0, binding = 11) uniform TileComputeParams
{
    vec4 tileSize;
    float bucketCount;
};
layout(std430, set = 0, binding = 12) readonly buffer Tiles
{
    uint buckets[];
};

layout(set = 1) uniform ShadingProperties
{
    float shadowConstantBias;
    float shadowNormalBias;
} prop;

layout(location = 0) out vec4 o_Color;

#define NearZero 0.000001

float pow2(float x)
{
    return x * x;
}

const vec2 invAtan = vec2(0.1591, 0.3183);
vec2 SphericalToUV(vec3 v)
{
    // -asin because we have top-left uv origin
    vec2 uv = vec2(atan(v.z, v.x), -asin(v.y));

    // convert to [0,1]
    uv *= invAtan;
    uv += 0.5;
    return uv;
}

vec3 Fresnel(vec3 albedo, float metallic, float dotVH)
{
    vec3 F0 = vec3(0.04); 
    F0      = mix(F0, albedo, metallic);
    float attenuation = pow(2, (-5.55472 * dotVH - 6.98316) * dotVH);
    return F0 + (1 - F0) * attenuation;
}

// https://google.github.io/filament/Filament.html
// this handles half precision well
#define MEDIUMP_FLT_MAX    65504.0
#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
float D_GGX_half(float roughness, float NoH, const vec3 n, const vec3 h) {
    vec3 NxH = cross(n, h);
    float a = NoH * roughness;
    float k = roughness / (dot(NxH, NxH) + a * a);
    float d = k * k * (1.0 / M_PI);
    return saturateMediump(d);
}

// original
float D_GGX(float NoH, float roughness) {
    // float r2 = roughness * roughness;
    // r2 / (M_PI * pow2(pow2(dotNH) * (r2 - 1) + 1));
    float a = NoH * roughness;
    float k = roughness / (1.0 - NoH * NoH + a * a);
    return k * k * (1.0 / M_PI);
}

float V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {
    float a2 = roughness * roughness;
    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}

vec3 SpecularBRDF(vec3 albedo, vec3 l, vec3 v, vec3 n, float metallic, float roughness, out vec3 F)
{
    vec3 h = normalize(l + v);
    float dotNH = clamp(dot(n, h), NearZero, 1);
    float dotNV = clamp(dot(n, v), NearZero, 1);
    float dotNL = clamp(dot(n, l), NearZero, 1);
    float dotVH = clamp(dot(v, h), NearZero, 1);

    float D = D_GGX_half(roughness, dotNH, n, h);

    // geometry
    float V = V_SmithGGXCorrelated(dotNV, dotNL, roughness);

    // fresnel
    F = Fresnel(albedo, metallic, dotVH);

    vec3 brdf = V * D * F;
    return brdf;
}

// http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Point+Light+Attenuation
float PointLightAttenuation(float distance, float t1, float t2)
{
    float s = distance / t2;
    if (s < 1)
    {
        s *= s;
        float n0 = (1 - s);
        return n0 * n0 / (1 + t1 * s);
    }
    else
        return 0;
}

// Real Shading in Unreal Engine 4
float PointLightInverseSquareFalloff(float distance, float lightRadius)
{
    float dis_light = distance / lightRadius;
    dis_light *= dis_light;
    dis_light *= dis_light;
    const float artisticControll = 1.0f;
    return pow2(clamp(1 - dis_light, 0, 1)) / (distance * distance + artisticControll);
}

#define OCCLUDER_SEARCH_ITS 100
vec3 ParallaxShadowReprojection(vec3 P1, vec3 L1, vec3 L0)
{ 
    float k = 1.0 + length(L1 - L0); 
    vec3 D = k * L1 - L0; 
 
    vec3 S = P1; 
    vec3 dS = D * 0.25; 
    float sum = 0, cnt = 0; 
    for (int i = 0; i < 8; ++i) 
    { 
        vec4 Sp = scene.worldToShadow * vec4(S, 1);
        Sp = Sp / Sp.w;
        vec2 shadowUV = Sp.xy * 0.5 + 0.5;
        float occDepth = textureLod(sampler2D(shadowMap, s_point_clamp), shadowUV, 0).r; 
        if (occDepth < Sp.z) 
        { 
            sum += (Sp.z - occDepth) * 1000.0f;  // shadow map is a depth texture from 0 to 1, we scale it with length of near and far plane
            cnt += 1; 
        } 
        S += dS; 
    } 
 
    float d0 = cnt > 0 ? sum * (1 / cnt) : 0; 
    vec3 P0 = P1 + d0 * D; 

    return P0;
} 
float GetMipLevelFromRoughness(float roughness)
{
    roughness = max(roughness, 0.001);
    if (roughness <= 0.2)
    {
        return mix(0, 1, (roughness - 0.001) / 0.2);
    }

    if (roughness <= 0.5)
    {
        return mix(1, 2, (roughness - 0.2) / 0.3);
    }

    if (roughness <= 0.8)
    {
        return mix(2, 3, (roughness - 0.5) / 0.3);
    }

    if (roughness <= 1)
    {
        return mix(3, 4, (roughness - 0.8) / 0.2);
    }

    return 0;
}

void main()
{
    vec3 n = normalize(DecodeGBufferNormal(texture(normalTex, i_UV).xyz));
    vec4 mask = texture(maskTex, i_UV);
    float metallic = mask.x;
    float roughness = mask.y;
    vec3 baseColor = texture(albedoTex, i_UV).xyz;
    float depth = texture(depthTex, i_UV).x;
    vec4 positionWS = scene.invNDCToWorld * vec4(i_UV * 2 - 1, depth, 1.0);
    positionWS /= positionWS.w;
    vec3 v = normalize(scene.viewPos.xyz - positionWS.xyz);

    vec3 color = vec3(0, 0, 0);
    for (int i = 0; i < scene.lightCount.x; ++i)
    {
        vec4 lightPos = scene.lights[i].position;
        vec3 l = lightPos.a == 0 ? lightPos.xyz : normalize(lightPos.xyz - positionWS.xyz);

        float dotNL = max(dot(n, l), NearZero);
        vec3 F;
        vec3 brdf = SpecularBRDF(baseColor, l, v, n, metallic, roughness, F);
        vec3 kd = 1 - F;
        kd *= 1 - metallic;

        vec3 light = dotNL * scene.lights[i].intensity * scene.lights[i].lightColor.xyz;
        float attenuation = lightPos.a == 0 ? 1 : PointLightInverseSquareFalloff(distance(lightPos.xyz, positionWS.xyz),  scene.lights[i].pointLightTerm2);
// scene.lights[i].pointLightTerm1,;

        vec3 lighting = light * (kd * baseColor / M_PI + brdf) * attenuation; // this looks wrong for metal, metal shouldn't diffuse too much
        // possible solution https://bruop.github.io/ibl/
        // const float DIELECTRIC_SPECULAR = 0.04;
        // diffuseColor = albedo.rgb * (1 - DIELECTRIC_SPECULAR) * (1.0 - metalness)

        // shadow mask
        float shadowAttenuation = 1.0;
        if (lightPos.a == 0)
        {
            const float shadowBias = prop.shadowConstantBias;
            const float shadowNormalBias = prop.shadowNormalBias;

            vec3 shadowWorldPos = positionWS.xyz;
            if (scene.cachedMainLightDirection.a == 1.0f)
            {
                shadowWorldPos = ParallaxShadowReprojection(positionWS.xyz, l, scene.cachedMainLightDirection.xyz);
            }

            vec4 shadowCS = scene.worldToShadow * vec4(shadowWorldPos.xyz + shadowNormalBias * n, 1.0);
            shadowCS = shadowCS / shadowCS.w;
            vec2 shadowUV = shadowCS.xy * 0.5 + 0.5;
            float objShadowDepth = shadowCS.z - shadowBias;
            if (shadowUV.x < 1 && shadowUV.y < 1 && shadowUV.x > 0 && shadowUV.y > 0)
            {
                shadowAttenuation = PcfShadow(shadowUV, objShadowDepth);
            }
        }
        color += lighting * shadowAttenuation;
    }

    // specular cube light
    float dotNV = clamp(dot(v, n), 0, 1);
    vec3 f0 = baseColor * metallic;
    float lod             = GetMipLevelFromRoughness(roughness);
    vec3 refVec = reflect(-v, n);
    vec3 prefilteredColor = textureLod(specularCube, refVec, lod).xyz;
    vec2 envBRDF          = texture(specularBRDFIntegrationMap, vec2(dotNV, roughness)).xy;
    // vec3 energyCompensation = 1.0 + f0 * (1.0 / envBRDF.x - 1.0);
    vec3 indirectSpecular = prefilteredColor * (f0 * envBRDF.x + envBRDF.y);// * energyCompensation;

    // diffuse cube light
    float ao = texture(aoMap, i_UV).x;
    vec3 diffuseCubeColor = texture(diffuseCube, n).xyz;
    vec3 ambient =  ao * baseColor * diffuseCubeColor / M_PI * (scene.lightCount.x > 0 ? scene.lights[0].ambientScale : 1);

    o_Color = vec4(color + ambient + indirectSpecular, 1);
    // uvec2 viewCoord = uvec2(gl_FragCoord.x, scene.screenSize.y - gl_FragCoord.y);
    // uvec2 tileIndex2D = uvec2(viewCoord / 16);
    // uint tileIndex = uint(tileIndex2D.x + tileIndex2D.y * tileSize.z);
    // bool hasLight = false;
    // for (uint i = 0; i < 4; ++i)
    // {
    //     hasLight = hasLight || (buckets[uint(tileIndex * 4 + i)] != 0);
    // }
    // if (hasLight)
    //     o_Color += vec4(0.31, 0, 0, 1);
}
#endif
