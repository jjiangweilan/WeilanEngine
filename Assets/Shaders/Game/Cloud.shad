#version 450
#include "Common/Common.glsl"

#if CONFIG
name: Game/Cloud
cull: back
blend:
- srcAlpha oneMinusSrcAlpha
#endif

struct v2f {
    vec3 positionWS;
    vec3 normalWS;
    vec2 uv;
};

#if VERT
layout(location = 0) in vec3 iPosition;
layout(location = 1) in vec3 iNormal;
layout(location = 2) in vec2 iUV;

layout(location = 0) out v2f vOut;
void main()
{
    vec3 positionWS = vec3(pconst.model * vec4(iPosition, 1)).xyz;
    vOut.normalWS = (inverse(transpose(mat3(pconst.model))) * iNormal);
    vOut.positionWS = positionWS.xyz;
    vOut.uv = iUV;
    gl_Position = scene.viewProjection * vec4(positionWS, 1);
}
#endif

#if FRAG

layout(set = 2, binding = 0) uniform Cloud
{
    vec4 position;
    float size;
    float delta;

    float worley_freq;
    float worley_amp;
    float worley_scale;

    float lacunarity;
    float gain;
    float densityScale;
    float cloudBlend;
    float fade;
} prop;

layout(set = 2, binding = 1) uniform sampler2D noiseTex;
layout(set = SET_GLOBAL, binding = 7) uniform Global
{
    float time;
} g;

#define USE_PERLIN_NOISE_3D
#define NOISE_WHITE_NOISE_TEX noiseTex
#define USE_WORLEY_NOISE_3D
#include "Lib/Noise.glsl"

layout(location = 0) in v2f fragInput;
layout(location = 0) out vec4 oColor;

float CloudDensity(vec3 pos)
{
    // Properties
    const int octaves = 3;
    float lacunarity = prop.lacunarity;
    float gain = prop.gain;
    //
    // Initial values
    float amplitude = prop.worley_amp;
    float frequency = prop.worley_freq;
    float val = 0;
    //

    val += 0.625 * (1 - worley3D(frequency * pos));
    val += 0.25 *  (1 - worley3D(frequency * 4 * pos));
    val += 0.125 * (1 - worley3D(frequency * 16 * pos));

    return val;
}

float BoxSdf(vec3 p)
{
  // mat4 model = pconst.model[3].xyz;
  vec3 q = abs(p - pconst.model[3].xyz) - vec3(length(pconst.model[0].xyz), length(pconst.model[1].xyz), length(pconst.model[2].xyz));
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float RayMarching(vec3 origin, vec3 dir)
{
    const float travelDistance = 20;
    const float delta = prop.delta > 0 ? prop.delta : 0.01f;

    float travel = 0.01;
    vec3 curr = origin;
    float distance = 0;
    for(;travel < travelDistance; travel += delta)
    {
        float boxSdf = BoxSdf(curr);
        if (boxSdf < 0)
        {
            float cloudDensity = mix(0, CloudDensity(curr + vec3(0,0,g.time)), prop.fade * clamp(-boxSdf, 0, 1 / prop.fade));
            distance += delta * cloudDensity;
        }

        curr += dir * delta;
    }

    return 1 - exp(-1 * distance * prop.densityScale);
}

void main()
{
    vec3 center = pconst.model[3].xyz + prop.position.xyz;
    vec3 dir = normalize(fragInput.positionWS.xyz - scene.viewPos.xyz);
    vec3 start = fragInput.positionWS.xyz;
    // float worley = prop.worley_amp * (1 - worley3D(fragInput.positionWS.xyz * prop.worley_freq));
    // float perlin = prop.perlin_amp * perlinNoise3D(fragInput.positionWS.xyz * prop.perlin_freq);
    // oColor = vec4(prop.amp * (perlinNoise3D(prop.freq * fragInput.positionWS.xyz) * 0.5f + 0.5f));
    // oColor = vec4(1,1,1,RayMarching(start, dir));
    // oColor = vec4(dir, 1);
    // oColor = vec4(hash(fragInput.positionWS.xyz),1.0);
    oColor = vec4(vec3(CloudDensity(fragInput.positionWS.xyz)), 1);
}
#endif
