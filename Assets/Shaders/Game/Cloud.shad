#version 450
#include "Common/Common.glsl"

#if CONFIG
name: Game/Cloud
cull: front
blend:
- one oneMinusSrcAlpha
#endif

struct v2f {
    vec3 positionWS;
    vec3 normalWS;
    vec2 uv;
};

#if VERT
layout(location = 0) in vec3 iPosition;
layout(location = 1) in vec3 iNormal;
layout(location = 2) in vec2 iUV;

layout(location = 0) out v2f vOut;
void main()
{
    vec3 positionWS = vec3(pconst.model * vec4(iPosition, 1)).xyz;
    vOut.normalWS = (inverse(transpose(mat3(pconst.model))) * iNormal);
    vOut.positionWS = positionWS.xyz;
    vOut.uv = iUV;
    gl_Position = scene.viewProjection * vec4(positionWS, 1);
}
#endif

#if FRAG

layout(set = 2, binding = 0) uniform Cloud
{
    vec4 position;
    float delta;
    float lightStep;
    float phaseFactor;

   // vec4 worley_freq;
   // vec4 perlin0_freq;
   // vec4 perlin1_freq;

    float cloudDensity;
    float absorption;
    float dualLobHenyeyGreenstein;
    vec4 cloudDensity_remap;
    vec2 edgeFade;
    float lightIntensityScale;
    vec4 sdfScale;
    vec4 lighting_remap;
    vec4 worley_amp;
} prop;

// layout(set = SET_GLOBAL, binding = 7) uniform Global
// {
//     float time;
// } g;

layout(set = 0, binding = 8) uniform sampler3D cloudDensity_linear_clampToBorder;

#define USE_PERLIN_NOISE_3D
#define USE_WORLEY_NOISE_3D
#include "Lib/Noise.glsl"
#include "Lib/Util.glsl"

layout(location = 0) in v2f fragInput;
layout(location = 0) out vec4 oColor;

// float CloudDensity(vec3 pos)
// {
//     pos += vec3(0,0,g.time/2);
//     //
//     // Initial values
//     vec4 frequency = prop.worley_freq;
//     float perlin = 0;
//     float worley = 0;
//
//     float norm = prop.perlin0_freq.x + prop.perlin0_freq.y + prop.perlin0_freq.z + prop.perlin0_freq.w + prop.perlin1_freq.x + prop.perlin1_freq.y + prop.perlin1_freq.z;
//
//     perlin += (perlinNoise3D(pos * prop.perlin0_freq.x) * 0.5 + 0.5) / (prop.perlin0_freq.x + 0.00001);
//     perlin += (perlinNoise3D(pos * prop.perlin0_freq.y) * 0.5 + 0.5) / (prop.perlin0_freq.y + 0.00001);
//     perlin += (perlinNoise3D(pos * prop.perlin0_freq.z) * 0.5 + 0.5) / (prop.perlin0_freq.z + 0.00001);
//     perlin += (perlinNoise3D(pos * prop.perlin0_freq.w) * 0.5 + 0.5) / (prop.perlin0_freq.w + 0.00001);
//
//     worley += 0.625 * (1 - worley3D(frequency.x * pos));
//     worley += 0.25 *  (1 - worley3D(frequency.y * pos));
//     worley += 0.125 * (1 - worley3D(frequency.z * pos));
//
//     float perlinWorley = remap(max(0,perlin), (max(0,worley)), 1, 0, 1);
//
//     // perlin worley
//     
//
//     return perlinWorley * prop.cloudDensity;
// }

float BoxSdf(vec3 p, float scale)
{
  // // mat4 model = pconst.model[3].xyz;
  vec3 b = 0.5 * scale * vec3(length(pconst.model[0].xyz), length(pconst.model[1].xyz), length(pconst.model[2].xyz));
  vec3 q = abs(p - pconst.model[3].xyz) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
  // return -length(p - pconst.model[3].xyz)+length(pconst.model[0].xyz);
}

float BoxSdf(vec3 p, vec3 scale)
{
  // // mat4 model = pconst.model[3].xyz;
  vec3 b = 0.5 * scale * vec3(length(pconst.model[0].xyz), length(pconst.model[1].xyz), length(pconst.model[2].xyz));
  vec3 q = abs(p - pconst.model[3].xyz) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
  // return -length(p - pconst.model[3].xyz)+length(pconst.model[0].xyz);
}

float Absorption(float d)
{
    return 2 * exp(-1 * d * prop.absorption) * (1-exp(-d*2));
}

float HenyeyGreenstein(float g, float costh)
{
    return (1.0 - g * g) / (4.0 * M_PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));
}

float DualLobHenyeyGreenstein(float g, float costh, float K)
{
    return mix(HenyeyGreenstein(-g, costh), HenyeyGreenstein(g, costh), K);
}

vec3 NormalizePosition(vec3 pos)
{
    // we use a 1m box
    vec3 extend = 0.5 * vec3(length(pconst.model[0].xyz), length(pconst.model[1].xyz), length(pconst.model[2].xyz));
    vec3 cubePos = pconst.model[3].xyz;

    vec3 o = (pos - cubePos + extend) / (2 * extend);
    return o;

}


float SampleCloudDensity(vec3 pos)
{
    vec4 cloud0 = texture(cloudDensity_linear_clampToBorder, NormalizePosition(pos));

    float perlinWorley = cloud0.x;
    float worley = cloud0.y * .625 + cloud0.z * .125 + cloud0.w * .25; 

    float cloud = remap(perlinWorley, worley - 1., 1., 0., 1.);

    return clamp(remap(cloud * prop.cloudDensity, prop.cloudDensity_remap),0, 1);
}

float SampleCloudDensity(vec3 pos, out vec3 normalizedPos)
{
    normalizedPos = NormalizePosition(pos);
    return clamp(remap(texture(cloudDensity_linear_clampToBorder, normalizedPos).x * prop.cloudDensity, prop.cloudDensity_remap.x, prop.cloudDensity_remap.y,prop.cloudDensity_remap.z,prop.cloudDensity_remap.w),0, 1);
}


float SampleCloudDensity1(vec3 uv)
{
    return clamp(remap(texture(cloudDensity_linear_clampToBorder, uv).x * prop.cloudDensity, prop.cloudDensity_remap.x, prop.cloudDensity_remap.y,prop.cloudDensity_remap.z,prop.cloudDensity_remap.w),0, 1);
}

float GetDensity(vec3 curr)
{
    float sdf = BoxSdf(curr, prop.sdfScale.xyz);
    vec3 normalizedPos = NormalizePosition(curr);

    vec4 cloud0 = texture(cloudDensity_linear_clampToBorder, normalizedPos);

    float perlinWorley = cloud0.x;
    float worley = cloud0.y * prop.worley_amp.x + cloud0.z * prop.worley_amp.y + cloud0.w * prop.worley_amp.z; 

    float cloud = remap(perlinWorley, worley - 1., 1., 0., 1.);

    return remap(cloud - max(sdf, 0)* prop.edgeFade.x, prop.cloudDensity_remap);
}

vec3 LightMarch(vec3 end, vec3 ldir)
{
    const float travelDistance = 20;
    const float delta = prop.lightStep > 0 ? prop.lightStep : 1;

    float travel = 0;
    vec3 curr = end - travelDistance * ldir;
    vec3 lightColor = vec3(prop.lightIntensityScale);
    vec4 light = vec4(0);
    for(;travel < travelDistance; travel += delta)
    {
        float cloudDensity = GetDensity(curr);

        if (cloudDensity > 0)
        {
            float den = cloudDensity;
            // float cloudDensity0 = GetDensity(curr + 0.3 * ldir);
            // float den1 = SampleCloudDensity(curr + 0.1 * ldir);

            // float ndotl = clamp(cloudDensity - cloudDensity0, 0, 1);
            float phaseCos = 1;
            float phase = DualLobHenyeyGreenstein(prop.phaseFactor, phaseCos, prop.dualLobHenyeyGreenstein);
            float reflectAbsorption = Absorption(den);
            // float ndotl = clamp((den - den1) / 0.3,0,1);

            vec4 col = vec4(lightColor.xyz, den);


            col.rgb *= (col.a * phase * reflectAbsorption );
            light += col * (1-light.a);
        }
        // float val = normalizedPos.y*2-1;
        // float heightDensity = clamp(-pow(abs(val), 6.0f) + 1,0, 1);
        // cloudDensity *= heightDensity;

        curr += ldir * delta;
    }

    return light.xyz;//Absorption(distance);
}

vec4 RayMarching1(vec3 origin, vec3 dir)
{
    const float travelDistance = 20;
    const float delta = prop.delta > 0 ? prop.delta : 0.01f;

    float travel = 0.01;
    vec3 curr = origin;
    float distance = 0;
    vec3 ldir = normalize(scene.lights[0].position.xyz);
    vec4 light = vec4(0);
    for(;travel < travelDistance; travel += delta)
    {
        float cloudDensity = GetDensity(curr);

        if (cloudDensity > 0)
        {
            float den = cloudDensity;
            float cloudDensity0 = GetDensity(curr + 0.1 * ldir);

            float ndotl = clamp(cloudDensity - cloudDensity0, 0, 1);
            vec3 l = vec3(vec3(0.93,0.85,0.75)*0.9 + prop.lightIntensityScale*vec3(1.0,0.6,0.3)*ndotl);

            float phaseCos = dot(-dir, -ldir);
            // float phase = DualLobHenyeyGreenstein(prop.phaseFactor, phaseCos, prop.dualLobHenyeyGreenstein);
            float absorption = Absorption(den);

            // vec3 lightColor = LightMarch(curr, ldir);
            vec4 col = vec4( mix( vec3(1.0,0.93,0.84), vec3(0.25,0.3,0.4), den), min(den * absorption, 1));
            col.rgb *= l * (col.a * absorption);// * phase );
            light += col * (1-light.a);
        }
        // float val = normalizedPos.y*2-1;
        // float heightDensity = clamp(-pow(abs(val), 6.0f) + 1,0, 1);
        // cloudDensity *= heightDensity;

        curr += dir * delta;
    }

    return light;
}

void main()
{
float len = length(fragInput.positionWS.xyz - scene.viewPos.xyz);
    vec3 dir = (fragInput.positionWS.xyz - scene.viewPos.xyz) / len;
    vec3 end = fragInput.positionWS.xyz;
    const float travelDistance = min(20, len);
    // float worley = prop.worley_amp * (1 - worley3D(fragInput.positionWS.xyz * prop.worley_freq));
    // float perlin = prop.perlin_amp * perlinNoise3D(fragInput.positionWS.xyz * prop.perlin_freq);
    // oColor = vec4(prop.amp * (perlinNoise3D(prop.freq * fragInput.positionWS.xyz) * 0.5f + 0.5f));

    vec4 lighting = RayMarching1(end - travelDistance * dir, dir);
    oColor = vec4(remap(lighting.xyz, prop.lighting_remap), clamp(lighting.a, 0, 1));//clamp(directAbsorption,0,1));

    // debugging
    // if (true)
    // {
    //     // requires blend mode srcAlpha oneMinusSrcAlpha
    //     float absorption = RayMarching1(start, dir);
    //     vec4 col = vec4(vec3(1), clamp(1 - absorption,0 ,1));
    //     oColor = col;//vec4(SampleCloudDensity(fragInput.positionWS.xyz));//clamp(directAbsorption,0,1));
    // }
    // else
    // {
    // oColor = vec4(vec3(SampleCloudDensity(fragInput.positionWS.xyz)), 1);
    // }
    // oColor = vec4(dir, 1);
    // oColor = vec4(hash(fragInput.positionWS.xyz),1.0);
}
#endif
