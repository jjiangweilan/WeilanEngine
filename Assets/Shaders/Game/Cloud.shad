#version 450
#include "Common/Common.glsl"
#define M_PI 3.14159265359

#if CONFIG
name: Game/Cloud
cull: back
blend:
- one srcAlpha
#endif

struct v2f {
    vec3 positionWS;
    vec3 normalWS;
    vec2 uv;
};

#if VERT
layout(location = 0) in vec3 iPosition;
layout(location = 1) in vec3 iNormal;
layout(location = 2) in vec2 iUV;

layout(location = 0) out v2f vOut;
void main()
{
    vec3 positionWS = vec3(pconst.model * vec4(iPosition, 1)).xyz;
    vOut.normalWS = (inverse(transpose(mat3(pconst.model))) * iNormal);
    vOut.positionWS = positionWS.xyz;
    vOut.uv = iUV;
    gl_Position = scene.viewProjection * vec4(positionWS, 1);
}
#endif

#if FRAG

layout(set = 2, binding = 0) uniform Cloud
{
    vec4 position;
    float size;
    float delta;
    float lightStep;
    float phaseFactor;

    vec4 worley_freq;
    vec4 perlin0_freq;
    vec4 perlin1_freq;

    float lacunarity;
    float gain;
    float densityScale;
    float cloudBlend;
    float fade;
    float dualLobHenyeyGreenstein;
} prop;

layout(set = 2, binding = 1) uniform sampler2D noiseTex;
layout(set = SET_GLOBAL, binding = 7) uniform Global
{
    float time;
} g;

#define USE_PERLIN_NOISE_3D
#define NOISE_WHITE_NOISE_TEX noiseTex
#define USE_WORLEY_NOISE_3D
#include "Lib/Noise.glsl"

layout(location = 0) in v2f fragInput;
layout(location = 0) out vec4 oColor;

float CloudDensity(vec3 pos)
{
    pos += vec3(0,0,g.time);
    //
    // Initial values
    vec4 frequency = prop.worley_freq;
    float val = 0;
    //

    float norm = prop.perlin0_freq.x + prop.perlin0_freq.y + prop.perlin0_freq.z + prop.perlin0_freq.w + prop.perlin1_freq.x + prop.perlin1_freq.y + prop.perlin1_freq.z;

    val += perlinNoise3D(pos * prop.perlin0_freq.x) / (prop.perlin0_freq.x);
    val += perlinNoise3D(pos * prop.perlin0_freq.y) / (prop.perlin0_freq.y);
    val += perlinNoise3D(pos * prop.perlin0_freq.z) / (prop.perlin0_freq.z);
    val += perlinNoise3D(pos * prop.perlin0_freq.w) / (prop.perlin0_freq.w);
    // val += perlinNoise3D(pos * prop.perlin1_freq.x) / (prop.perlin1_freq.x);
    // val += perlinNoise3D(pos * prop.perlin1_freq.y) / (prop.perlin1_freq.y);
    // val += perlinNoise3D(pos * prop.perlin1_freq.z) / (prop.perlin1_freq.z);
    // val += perlinNoise3D(pos * prop.perlin1_freq.z);


    // val += 0.625 * (1 - worley3D(frequency.x * pos));
    // val += 0.25 *  (1 - worley3D(frequency.y * pos));
    // val += 0.125 * (1 - worley3D(frequency.z * pos));

    return abs(2 * val + 1);
}

float BoxSdf(vec3 p)
{
  // mat4 model = pconst.model[3].xyz;
  vec3 q = abs(p - pconst.model[3].xyz) - vec3(length(pconst.model[0].xyz), length(pconst.model[1].xyz), length(pconst.model[2].xyz));
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}

float Absorption(float d)
{
    return exp(-1 * d * prop.densityScale);
}

float HenyeyGreenstein(float g, float costh)
{
    return (1.0 - g * g) / (4.0 * M_PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0/2.0));
}

float DualLobHenyeyGreenstein(float g, float costh, float K)
{
    return mix(HenyeyGreenstein(-g, costh), HenyeyGreenstein(g, costh), K);
}

// dir: pointing to light
float LightAbsorption(vec3 start, vec3 dir)
{
    const float travelDistance = 20;
    const float delta = prop.lightStep > 0 ? prop.lightStep : 1;

    float travel = 0;
    vec3 curr = start;
    float distance = 0;
    for(;travel < travelDistance; travel += delta)
    {
        float boxSdf = BoxSdf(curr);
        if (boxSdf < 0)
        {
            float cloudDensity = CloudDensity(curr);
            distance += delta * cloudDensity;
        }

        curr += dir * delta;
    }

    return Absorption(distance);
}

vec3 RayMarching(vec3 origin, vec3 dir, out float directAbsorption)
{
    const float travelDistance = 20;
    const float delta = prop.delta > 0 ? prop.delta : 0.01f;

    float travel = 0;
    vec3 curr = origin;
    vec3 lighting = vec3(0);
    float distance = 0;
    vec3 L = vec3(scene.lights[0].intensity);
    float normFactor = 0;
    for(;travel < travelDistance; travel += delta)
    {
        float boxSdf = BoxSdf(curr);
        if (boxSdf < 0)
        {
            float cloudDensity = CloudDensity(curr);
            distance += delta * cloudDensity;
            
            vec3 ldir = normalize(scene.lights[0].position.xyz);
            float phaseCos = dot(-ldir, -dir);
            float phase = DualLobHenyeyGreenstein(prop.phaseFactor, phaseCos, prop.dualLobHenyeyGreenstein);
            float reflectAbsorption = Absorption(distance);
            lighting += reflectAbsorption * L * phase * LightAbsorption(curr, ldir);
            normFactor += 1;
        }

        curr += dir * delta;
    }

    directAbsorption = Absorption(distance);
    lighting /= normFactor;
    return lighting;
}

void main()
{
    vec3 center = pconst.model[3].xyz + prop.position.xyz;
    vec3 dir = normalize(fragInput.positionWS.xyz - scene.viewPos.xyz);
    vec3 start = fragInput.positionWS.xyz;
    // float worley = prop.worley_amp * (1 - worley3D(fragInput.positionWS.xyz * prop.worley_freq));
    // float perlin = prop.perlin_amp * perlinNoise3D(fragInput.positionWS.xyz * prop.perlin_freq);
    // oColor = vec4(prop.amp * (perlinNoise3D(prop.freq * fragInput.positionWS.xyz) * 0.5f + 0.5f));
    float directAbsorption;
    vec3 lighting = RayMarching(start, dir, directAbsorption);
    oColor = vec4(lighting, clamp(directAbsorption,0,1));
    // oColor = vec4(dir, 1);
    // oColor = vec4(hash(fragInput.positionWS.xyz),1.0);
    // oColor = vec4(vec3(CloudDensity(fragInput.positionWS.xyz)), 1);
}
#endif
