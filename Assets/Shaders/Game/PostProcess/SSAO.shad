#version 460
#if CONFIG
name : Game / PostProcess / SSAO
features :
    - [ _CrysisAO, _AlchemyAO, _GTAO ]
#endif

#include "Utils/FullScreen.glsl"
#include "Common/SceneInfo.glsl"
#include "Utils/SpaceConversion.glsl"

#if FRAG

#include "Common/DeferredShading.glsl"
#include "Utils/NormalReconstruction.glsl"

layout(location = 0) in vec2 uv;
layout(location = 0) out float oAO;

layout(set = 0, binding = 1) uniform sampler2D depth_point_clamp;
layout(set = 0, binding = 2) uniform sampler2D noise_linear;

#define noiseTex noise_linear
#define depthTex depth_point_clamp
// #define normalTex normal_clamp

#ifdef _CrysisAO

#define SSAO_SAMPLE_COUNT 64
layout(set = 1) uniform SSAO
{
    vec4 samples[SSAO_SAMPLE_COUNT];
} ssao;

layout(set = 1) uniform SSAOParam
{
    vec4 sourceTexelSize;
    float bias;
    float radius;
    float rangeCheck;
} param;

float GetSSAO()
{
    float depthVal = texture(depthTex, uv).x;
    vec3 screenPos = vec3(uv * 2 - 1, depthVal);
    vec4 pixelVS = scene.invProjection * vec4(screenPos, 1.0);
    pixelVS /= pixelVS.w;

    vec3 normalVS = NormalReconstructionLow(pixelVS.xyz); // mat3(scene.view) * (DecodeGBufferNormal(texture(normalTex, uv).xyz));

    vec3 anyVec = vec3(1, 0, 0);
    anyVec = all(equal(normalVS, anyVec)) ? vec3(0, 1, 0) : anyVec;
    vec3 tangent = normalize(anyVec - normalVS * dot(anyVec, normalVS));
    vec3 bitangent = cross(normalVS, tangent);
    mat3 TBN = mat3(tangent, bitangent, normalVS);

    // const float bias = 0.005;
    float occlusion = 0;
    const float depthValVS = LinearEyeDepth(depthVal, scene.cameraZBufferParams);
    for (int i = 0; i < SSAO_SAMPLE_COUNT; ++i)
    {
        vec3 sampleVS = pixelVS.xyz + TBN * ssao.samples[i].xyz * param.radius;
        vec4 sampleCS = scene.projection * vec4(sampleVS, 1.0);
        sampleCS /= sampleCS.w;

        vec2 uv = sampleCS.xy * 0.5 + 0.5;
        float sampleDepth = LinearEyeDepth(texture(depthTex, uv).x, scene.cameraZBufferParams);
        float sampleCSLinearZ = LinearEyeDepth(sampleCS.z, scene.cameraZBufferParams);

        float rangeCheck = smoothstep(0.0, 1.0f, param.rangeCheck * param.radius / abs(depthValVS - sampleDepth));
        occlusion += (sampleDepth >= (sampleCSLinearZ + param.bias) ? 0.0f : 1.0f) * rangeCheck;
    }
    occlusion /= SSAO_SAMPLE_COUNT;

    return 1 - occlusion;
}
#endif

#ifdef _AlchemyAO

layout(set = 1) uniform SSAOParam
{
    vec4 sourceTexelSize;
    float sigma;
    float k;
    float beta;
    float theta;

    float sampleCount;
    float radius;
    float rangeCheck;
} param;

#define M_PI 3.14159265359f

// vec2 in [-1, 1] in a disk
vec2 PickSampleOffsetDisk(vec2 uv, int i, float sampleCount)
{
    float noiseVal = texture(noiseTex, uv * param.sourceTexelSize.zw / 128.0f).x;
    float u = ((i + 1) / sampleCount);
    float r = u * 6 * M_PI;
    return vec2(cos(r), sin(r)) * noiseVal;
}

float GetSSAO()
{
    float depth = texture(depthTex, uv).x;
    vec4 posNDC = vec4(uv * 2 - 1, depth, 1.0);
    vec4 posVS = scene.invProjection * posNDC;
    posVS /= posVS.w;

    vec3 normalVS = NormalReconstructionLow(posVS.xyz); //mat3(scene.view) * DecodeGBufferNormal(texture(normalTex, uv).xyz);

    const float sampleCount = param.sampleCount;
    float A = 0;
    for (int i = 0; i < sampleCount; ++i)
    {
        vec2 offset = param.radius * PickSampleOffsetDisk(uv, i, sampleCount);
        vec4 sampleVS = vec4(posVS.xyz + vec3(offset, 0), 1.0f);
        vec4 sampleCS = scene.projection * sampleVS;
        sampleCS /= sampleCS.w;
        sampleCS.xy = sampleCS.xy * 0.5 + 0.5;
        float sampleFragDepth = texture(depthTex, sampleCS.xy).x;

        vec4 sampleVS2 = scene.invProjection * vec4(sampleCS.xy * 2 - 1, sampleFragDepth, 1.0);
        sampleVS2 /= sampleVS2.w;

        vec3 vi = sampleVS2.xyz - posVS.xyz;

        float vi_n = dot(vi, normalVS);
        float vi_vi = dot(vi, vi);
        float rangeCheck = 1 - clamp(length(vi) * param.rangeCheck / param.radius, 0.0, 1.0);
        A += max(0, vi_n - posVS.z * param.beta) / (vi_vi + param.theta) * rangeCheck;
    }

    A = max(0, pow(2 * param.sigma / sampleCount * A, param.k));

    return 1 - A;
}
#endif

#ifdef _GTAO
#include "SSAO/GTAO.glsl"
#endif

void main()
{
    float occlusion = GetSSAO();
    oAO = occlusion;
}

#endif
