#version 450

#if CONFIG
name: Game/PostProcess/SSAO
mask: B
features:
    - [_CrysisAO, _AlchemyAO]
#endif

#include "Utils/FullScreen.glsl"
#include "Common/SceneInfo.glsl"
#include "Utils/SpaceConversion.glsl"

#if FRAG

#include "Common/DeferredShading.glsl"

layout(location = 0) in vec2 uv;
layout(location = 0) out vec4 oAO;

layout(set = 0) uniform sampler2D depth_clamp;
layout(set = 0) uniform sampler2D normal_clamp;
#ifdef _AlchemyAO
layout(set = 0) uniform sampler2D noise_point;
#endif

#define noiseTex noise_point;
#define depthTex depth_clamp
#define normalTex normal_clamp

#define SSAO_SAMPLE_COUNT 64
layout(set = 1) uniform SSAO
{
    vec4 samples[SSAO_SAMPLE_COUNT];
} ssao;

#ifdef _CrysisAO

layout(set = 1, binding = 0) uniform SSAOParam
{
    vec4 sourceTexelSize;
    float bias;
    float radius;
    float rangeCheck;
} param;

float GetSSAO()
{
    vec3 normalVS = mat3(scene.view) * (DecodeGBufferNormal(texture(normalTex, uv).xyz));

    float depthVal = texture(depthTex, uv).x;
    vec3 screenPos = vec3(uv * 2 - 1, depthVal);
    vec4 pixelVS = scene.invProjection * vec4(screenPos, 1.0);
    pixelVS /= pixelVS.w;

    vec3 anyVec = vec3(1,0,0);
    anyVec = all(equal(normalVS, anyVec)) ? vec3(0,1,0) : anyVec;
    vec3 tangent   = normalize(anyVec - normalVS * dot(anyVec, normalVS));
    vec3 bitangent = cross(normalVS, tangent);
    mat3 TBN       = mat3(tangent, bitangent, normalVS); 

    // const float bias = 0.005;
    float occlusion = 0;
    const float depthValVS = LinearEyeDepth(depthVal);
    for(int i = 0; i < SSAO_SAMPLE_COUNT; ++i)
    {
        vec3 sampleVS = pixelVS.xyz + TBN * ssao.samples[i].xyz * param.radius;
        vec4 sampleCS = scene.projection * vec4(sampleVS, 1.0);
        sampleCS /= sampleCS.w;

        vec2 uv = sampleCS.xy * 0.5 + 0.5;
        float sampleDepth = LinearEyeDepth(texture(depthTex, uv).x);
        float sampleCSLinearZ = LinearEyeDepth(sampleCS.z);

        float rangeCheck = smoothstep(0.0, 1.0f, param.rangeCheck * param.radius / abs(depthValVS - sampleDepth));
        occlusion  += (sampleDepth >= (sampleCSLinearZ + param.bias) ? 0.0f : 1.0f) * rangeCheck;
    }
    occlusion /= SSAO_SAMPLE_COUNT;

    return occlusion;
}
#endif

#ifdef _AlchemyAO

layout(set = 1, binding = 1) uniform SSAOParam
{
    vec4 sourceTexelSize;
    float u;
    float u_2; // u^2
    float sampleCount;
    float radius;
} param;

#define M_PI 3.14159265359f

// vec2 in [-1, 1] in a disk
vec2 PickSampleOffsetDisk(vec2 uv, int i)
{
    float noise = texture(noise_point, uv + vec2(i * 123, i * 12)).x;
    noise *= 2 * M_PI;

    return vec2(cos(noise), sin(noise));
}

float GetSSAO()
{
    float depth = texture(depthTex, uv).x;
    vec4 posVS = scene.invProjection * vec4(uv * 2 - 1, depth, 1.0);
    posVS /= posVS.w;

    vec3 normalVS = mat3(scene.view) * texture(normalTex, uv).xyz;

    const float sampleCount = param.sampleCount;
    float A = 0;
    for(int i = 0; i < sampleCount; ++i)
    {
        vec2 offset = 8 * param.sourceTexelSize.xy * PickSampleOffsetDisk(uv, i);
        vec2 sampleUV = uv + offset;
        float sampleFragDepth = texture(depthTex, sampleUV).x;

        vec4 sampleVS2 = scene.invProjection * vec4(sampleUV, sampleFragDepth, 1.0);
        sampleVS2 /= sampleVS2.w;

        vec3 vi = sampleVS2.xyz - posVS.xyz;

        A += max(0, dot(vi, normalVS)) * step(0, param.radius - length(vi)) / max(param.u_2, dot(vi, vi));
    }

    A = 2 * M_PI * param.u / sampleCount * A;

    return A;
}
#endif

void main()
{
    float occlusion = GetSSAO();
    oAO = vec4(0, 0, 1 - occlusion, 0);
}

#endif
